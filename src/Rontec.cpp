static const char *RcsId = "$Header: /users/chaize/newsvn/cvsroot/Instrumentation/Rontec/src/Rontec.cpp,v 1.1.1.1 2005-09-30 12:13:33 syldup Exp $";
//+=============================================================================
//
// file : 				Rontec.cpp
//
// description :	C++ source for the Rontec and its commands.
//								The class is derived from Device. It represents the
//								CORBA servant object which will be accessed from the
//								network. All commands which can be executed on the
//								Rontec are implemented in this file.
//
// project :			TANGO Device Server
//
// $Author: syldup $
//
// $Revision: 1.1.1.1 $
//
// $Log: not supported by cvs2svn $
// Revision 1.1  2005/09/09 15:38:21  coquet
// initial import, tested with real hardware.
// Raw version, a lot of functions are not implemented ( hard-coded ) but DS is usable
//
//
// copyleft : 		Synchrotron SOLEIL
//								L'Orme des Merisiers
//								Saint-Aubin - BP 48
//
//-=============================================================================
//
//			This file is generated by POGO
//	(Program Obviously used to Generate tango Object)
//
//				 (c) - Software Engineering Group - ESRF
//=============================================================================



//===================================================================
//
//	The folowing table gives the correspondance
//	between commands and method's name.
//
//	Command's name											|  Method's name
//	----------------------------------------
//	State 															|  dev_state()
//	Status															|  dev_status()
//	Start 															|  start()
//	Stop																|  stop()
//	SetStartingChannel									|  set_starting_channel()
//	SetEndingChannel										|  set_ending_channel()
//	GetSpectrumLimits 									|  get_spectrum_limits()
//	GetSpeedAndResolutionConfiguration	|  get_speed_and_resolution_configuration()
//	SetSpeedAndResolutionConfiguration	|  set_speed_and_resolution_configuration()
//	GetRemainingAcquisitionTime 				|  get_remaining_acquisition_time()
//	SetROIParameters										|  set_roiparameters()
//	GetROIParameters										|  get_roiparameters()
//	GetRoiCount 												|  get_roi_count()
//	Reset 															|  reset()
//	Clear 															|  clear()
//	InitSerialLine											|  init_serial_line()
//	GetDetectorTemperature							|  get_detector_temperature()
//	GetInputCountRate 									|  get_input_count_rate()
//	GetOutputCountRate									|  get_output_count_rate()
//	GetDeadTime 												|  get_dead_time()
//	GetCycleTime												|  get_cycle_time()
//	GetPartOfSpectrum 									|  get_part_of_spectrum()
//	GetEnergyRange											|  get_energy_range()
//	GetOffsetGain 											|  get_offset_gain()
//	GetPauseStatus											|  get_pause_status()
//	SetReadSize 												|  set_read_size()
//	GetAcquisitionTime									|  get_acquisition_time()
//	SetEnergyRange											|  set_energy_range()
//	SendRontecMessage 									|  send_rontec_message()
//
//===================================================================


#include <tango.h>
#include <Rontec.h>
#include <RontecClass.h>
#include <PogoHelper.h>
#include <XString.h>

namespace Rontec_ns
{

//+----------------------------------------------------------------------------
//
// method : 		Rontec::Rontec(string &s)
// 
// description :	constructor for simulated Rontec
//
// in : - cl : Pointer to the DeviceClass object
//			- s : Device name 
//
//-----------------------------------------------------------------------------
Rontec::Rontec(Tango::DeviceClass *cl,string &s)
:Tango::Device_3Impl(cl,s.c_str())
{
	init_device();
}

Rontec::Rontec(Tango::DeviceClass *cl,const char *s)
:Tango::Device_3Impl(cl,s)
{
	init_device();
}

Rontec::Rontec(Tango::DeviceClass *cl,const char *s,const char *d)
:Tango::Device_3Impl(cl,s,d)
{
	init_device();
}
//+----------------------------------------------------------------------------
//
// method : 		Rontec::delete_device()
//
// description :	will be called at device destruction or at init command.
//
//-----------------------------------------------------------------------------
void Rontec::delete_device()
{
	//	Delete device's allocated object
	DELETE_SPECTRUM_ATTRIBUTE(attr_fluoSpectrum_read);

	// DeviceProxyHelper on serial line device
	if( _serialProxy_helper )
	{
		delete _serialProxy_helper;
		_serialProxy_helper = 0;
	}
	// Rontec MCA implementation class
	if( mca )
	{
		delete mca;
		mca = 0;
	}
	// thread : do not delete!!!	use abort() to exit from run_undetached instead
	if(spectrum_reader)
	{
		spectrum_reader->abort();
		spectrum_reader = 0;
	}

}

//+----------------------------------------------------------------------------
//
// method : 		Rontec::init_device()
// 
// description :	will be called at device initialization.
//
//-----------------------------------------------------------------------------
void Rontec::init_device()
{
	INFO_STREAM << "Rontec::Rontec() create device " << device_name << endl;

	// Initialise variables to default values
	//--------------------------------------------
	get_device_property();

	CREATE_SPECTRUM_ATTRIBUTE(attr_fluoSpectrum_read, numberOfChannels);

	// pointers on classes
	// serial line device
	_serialProxy_helper=0;
	// rontec implementation class
	mca = 0;
	// thread for spectrum cyclic reading
	spectrum_reader = 0;
	// initialisation flags
	_serial_line_initialised = false;
	init_rontec_done = false;
	init_thread_done = false;

	this->acquisition_start_channel = 0;
	this->acquisition_end_channel = numberOfChannels;
	status_str = "device starting";


	// creates the DeviceProxyHelper and initialises the serial line
	// DeviceProxyHelper raises exception if	creation fails
	INFO_STREAM << "Rontec::init_device() trying to create deviceProxy on serial line device server " << serialLineUrl << endl;
	if( !_serial_line_initialised )
	{
		// all the stuff is in that method
		init_serial_line();
		_serial_line_initialised = true;
	}

	if(!init_rontec_done)
	{
		if(mca )
		{
			delete mca;
			mca = 0;
		}

		// Rontec MCA implementation class
		try
		{
			// RONTEC implementation class
			INFO_STREAM << "Rontec::init_device() trying to create instance of RontecMcaImplementation class " << endl;
			mca = new RontecMcaImplementation(this,
																			_serialProxy_helper,
																			0,
																			numberOfChannels
																			);
			mca->configure_acquisition_mode();
			init_rontec_done = true;
		}
		catch(...)
		{
			FATAL_STREAM	<< "Rontec::init_device() OUT_OF_MEMORY failed to create instance of RontecMcaImplementation class " << endl;
			std::cout << "Rontec::init_device() in catch ( ... ) OUT_OF_MEMORY failed to create instance of RontecMcaImplementation class " << endl;
			init_rontec_done = false;
			Tango::Except::throw_exception (
					(const char *)"OUT_OF_MEMORY",
					(const char *)" failed to create instance of RontecMcaImplementation utility class",
					(const char *)"Rontec::init_device");
		}

		// thread creation
		if(spectrum_reader)
		{
			spectrum_reader->abort();
			spectrum_reader = 0;
		}
		INFO_STREAM << "Rontec::init_device() trying to create instance of readingthread class " << endl;
		try
		{
			// create acquisition thread
			spectrum_reader = new readingthread( this,
																				 mca,
																				 &serial_access, // the mutex
																				 0,
																				 static_cast<unsigned long>(100000000),
																				 512 );
			init_thread_done = true;
		}
		catch(...)
		{
			FATAL_STREAM	<< "Rontec::init_device() OUT_OF_MEMORY failed to create instance of readingthread class " << endl;
			std::cout << "Rontec::init_device() in catch ( ... ) OUT_OF_MEMORY failed to create instance of readingthread class " << endl;
			init_thread_done = false;
			Tango::Except::throw_exception (
					(const char *)"OUT_OF_MEMORY",
					(const char *)" failed to create instance of readingthread	class",
					(const char *)"Rontec::init_device");
		}
	}

}


//+----------------------------------------------------------------------------
//
// method : 		Rontec::readDeviceProperies()
// 
// description :	Read the device properties from database.
//
//-----------------------------------------------------------------------------
void Rontec::get_device_property()
{
	//	Initialize your default values here.
	//------------------------------------------

	baud =38400;
	serialLineUrl = "rontec/test/serial";
	connectedROIMask = "1 2";
	numberOfChannels = 4096;
	maxFluoEnergy = 80.0;

	//	Read device properties from database.(Automatic code generation)
	//-------------------------------------------------------------
	if (Tango::Util::instance()->_UseDb==false)
		return;
	Tango::DbData dev_prop;
	dev_prop.push_back(Tango::DbDatum("Baud"));
	dev_prop.push_back(Tango::DbDatum("SerialLineUrl"));
	dev_prop.push_back(Tango::DbDatum("ConnectedROIMask"));
	dev_prop.push_back(Tango::DbDatum("NumberOfChannels"));
	dev_prop.push_back(Tango::DbDatum("MaxFluoEnergy"));

	//	Call database and extract values
	//--------------------------------------------
	get_db_device()->get_property(dev_prop);
	RontecClass *ds_class =
		(static_cast<RontecClass *>(get_device_class()));
	int i = -1;
	//	Extract Baud value
	if (dev_prop[++i].is_empty()==false)	dev_prop[i]  >>  baud;
	else
	{
		//	Try to get value from class property
		Tango::DbDatum	cl_prop = ds_class->get_class_property(dev_prop[i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  baud;
	}

	//	Extract SerialLineUrl value
	if (dev_prop[++i].is_empty()==false)	dev_prop[i]  >>  serialLineUrl;
	else
	{
		//	Try to get value from class property
		Tango::DbDatum	cl_prop = ds_class->get_class_property(dev_prop[i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  serialLineUrl;
	}

	//	Extract ConnectedROIMask value
	if (dev_prop[++i].is_empty()==false)	dev_prop[i]  >>  connectedROIMask;
	else
	{
		//	Try to get value from class property
		Tango::DbDatum	cl_prop = ds_class->get_class_property(dev_prop[i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  connectedROIMask;
	}

	//	Extract NumberOfChannels value
	if (dev_prop[++i].is_empty()==false)	dev_prop[i]  >>  numberOfChannels;
	else
	{
		//	Try to get value from class property
		Tango::DbDatum	cl_prop = ds_class->get_class_property(dev_prop[i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  numberOfChannels;
	}

	//	Extract MaxFluoEnergy value
	if (dev_prop[++i].is_empty()==false)	dev_prop[i]  >>  maxFluoEnergy;
	else
	{
		//	Try to get value from class property
		Tango::DbDatum	cl_prop = ds_class->get_class_property(dev_prop[i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  maxFluoEnergy;
	}



	//	End of Automatic code generation
	//-------------------------------------------------------------
	// create properties ( init to default values ) if necessary
	Tango::DbData data_put;
	if (dev_prop[0].is_empty()==true)
	{
		Tango::DbDatum	property("Baud");
		property	<<	baud;
		data_put.push_back(property);
	}
	if (dev_prop[1].is_empty()==true)
	{
		Tango::DbDatum	property("SerialLineUrl");
		property	<<	serialLineUrl;
		data_put.push_back(property);
	}
	if (dev_prop[2].is_empty()==true)
	{
		Tango::DbDatum	property("ConnectedROIMask");
		property	<<	connectedROIMask;
		data_put.push_back(property);
	}
	if (dev_prop[3].is_empty()==true)
	{
		Tango::DbDatum	property("NumberOfChannels");
		property	<<	numberOfChannels;
		data_put.push_back(property);
	}
	if (dev_prop[4].is_empty()==true)
	{
		Tango::DbDatum	property("MaxFluoEnergy");
		property	<<	maxFluoEnergy;
		data_put.push_back(property);
	}
	get_db_device()->put_property(data_put);



}
//+----------------------------------------------------------------------------
//
// method : 		Rontec::always_executed_hook()
// 
// description :	method always executed before any command is executed
//
//-----------------------------------------------------------------------------
void Rontec::always_executed_hook()
{

}
//+----------------------------------------------------------------------------
//
// method : 		Rontec::read_attr_hardware
// 
// description :	Hardware acquisition for attributes.
//
//-----------------------------------------------------------------------------
void Rontec::read_attr_hardware(vector<long> &attr_list)
{
	DEBUG_STREAM << "Rontec::read_attr_hardware(vector<long> &attr_list) entering... "<< endl;
	//	Add your own code here
}

//+----------------------------------------------------------------------------
//
// method : 		Rontec::read_fluoSpectrum
// 
// description :	Extract real attribute values for fluoSpectrum acquisition result.
//
//-----------------------------------------------------------------------------
void Rontec::read_fluoSpectrum(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Rontec::read_fluoSpectrum(Tango::Attribute &attr) entering... "<< endl;
	unsigned long * dat = 0;
	try
	{
		dat = spectrum_reader->get_spectrum();
		for(int i = 0; i < numberOfChannels; i++)
		{
			attr_fluoSpectrum_read[i] = ( Tango::DevDouble)(dat[i]);
		}
	}
	catch(Tango::DevFailed & e)
	{
		FATAL_STREAM << "Rontec::read_fluoSpectrum(): catched DevFailed Exception" << endl;
		Tango::Except::re_throw_exception (e,
			(const char *)"catched Tango exception",
			(const char *)" rethrown here",
			(const char *)"Rontec::read_fluoSpectrum()");
	}
	catch(...)
	{
		FATAL_STREAM << "Rontec::read_fluoSpectrum(): catched (...) Exception" << endl;
		Tango::Except::throw_exception (
			(const char *)"catched unknown exception",
			(const char *)"only rethrown here",
			(const char *)"Rontec::read_fluoSpectrum()");
	}

	attr.set_value(attr_fluoSpectrum_read, numberOfChannels);
}




//+------------------------------------------------------------------
/**
 *	method: Rontec::start
 *
 *	description:	method to execute "Start"
 *	starts a acquisition previously configured with SetStartingChannel, SetEndingChannel
 *	for time given in argin
 *	clears memory in the MCA if not done.
 *	for continuous acquisition : argin = 0
 *
 * @param argin time in sec.ms
 *
 */
//+------------------------------------------------------------------
void Rontec::start(Tango::DevFloat argin)
{
	DEBUG_STREAM << "Rontec::start(): entering... !" << endl;
	//	Add your own code to control device here

	//	Add your own code to control device here
	// pas besoin de catcher les exceptions : la classe mutex unlocke toute seule a sa destruction
	// use of automatic_mutex :
	// la classe locke le mutex passé en argument ( pointeur ) a la creation 
	// unlock du mutex a la destruction de la classe ( en fin de visibilité si statique 
	// c'est la fin de visibilite qui nous interesse le mutex est unlocked de facon sure
	// donc alloc statique
	automatic_mutex m(&serial_access);
	// clear the spectrum memory buffer in the RONTEC
	mca->clear();
	// configure RONTEC :
	// format : data will be returned as 4-bytes integers
	// mode 	: rontec sends accumulated spectrum ( do not clear after transmit )
	mca->configure_acquisition_mode(4,0);
	mca->start_acquisition(argin);

	// start acquisition on the RONTEC
	// start the thread if necessary
	if( !spectrum_reader->is_started())
			spectrum_reader->go();
	// restart a paused thread
	if( spectrum_reader->is_paused())
			spectrum_reader->resume();
}

//+------------------------------------------------------------------
/**
 *	method: Rontec::stop
 *
 *	description:	method to execute "Stop"
 *	stops acquisition already running
 *
 *
 */
//+------------------------------------------------------------------
void Rontec::stop()
{
	DEBUG_STREAM << "Rontec::stop(): entering... !" << endl;
	//	Add your own code to control device here

		// use of automatic_mutex :
		// la classe locke le mutex passé en argument ( pointeur ) a la creation 
		// unlock du mutex a la destruction de la classe ( en fin de visibilité si statique 
		// c'est la fin de visibilite qui nous interesse le mutex est unlocked de facon sure
		// donc alloc statique
		automatic_mutex m(&serial_access);
		mca->pause();
	// restart a paused spectrum acquisition thread
	if( !spectrum_reader->is_paused())
			spectrum_reader->pause();
}

//+------------------------------------------------------------------
/**
 *	method: Rontec::set_starting_channel
 *
 *	description:	method to execute "SetStartingChannel"
 *	sets the starting channel of the spectrum to be read.
 *
 * @param argin first channel of the spectrum to be read
 *
 */
//+------------------------------------------------------------------
void Rontec::set_starting_channel(Tango::DevLong argin)
{
	DEBUG_STREAM << "Rontec::set_starting_channel(): entering... !" << endl;

	//	Add your own code to control device here
		// use of automatic_mutex :
		// la classe locke le mutex passé en argument ( pointeur ) a la creation
		// unlock du mutex a la destruction de la classe ( en fin de visibilité si statique
		// c'est la fin de visibilite qui nous interesse le mutex est unlocked de facon sure
		// donc alloc statique
		automatic_mutex m(&serial_access);
		mca->set_spectrum_reading_first_channel(argin);
}

//+------------------------------------------------------------------
/**
 *	method: Rontec::set_ending_channel
 *
 *	description:	method to execute "SetEndingChannel"
 *	sets the last spectrum channel to be returned by the rontec
 *	must be <= NumberOfChannels property
 *
 * @param argin last channel to be returned
 *
 */
//+------------------------------------------------------------------
void Rontec::set_ending_channel(Tango::DevLong argin)
{
	DEBUG_STREAM << "Rontec::set_ending_channel(): entering... !" << endl;

	//	Add your own code to control device here
		// use of automatic_mutex :
		// la classe locke le mutex passé en argument ( pointeur ) a la creation 
		// unlock du mutex a la destruction de la classe ( en fin de visibilité si statique 
		// c'est la fin de visibilite qui nous interesse le mutex est unlocked de facon sure
		// donc alloc statique
		automatic_mutex m(&serial_access);
		mca->set_spectrum_reading_last_channel(argin);
}

//+------------------------------------------------------------------
/**
 *	method: Rontec::get_spectrum_limits
 *
 *	description:	method to execute "GetSpectrumLimits"
 *	returns in [0] the starting channel,
 *	in [1] the ending channnel
 *	as configured previously with SetStartingChannel, SetEndingChannel
 *
 * @return	the low and high spectrum limits
 *
 */
//+------------------------------------------------------------------
Tango::DevVarLongArray *Rontec::get_spectrum_limits()
{
	//	POGO has generated a method core with argout allocation.
	//	If you would like to use a static reference without copying,
	//	See "TANGO Device Server Programmer's Manual"
	//		(chapter : Writing a TANGO DS / Exchanging data)
	//------------------------------------------------------------
	Tango::DevVarLongArray	*argout  = new Tango::DevVarLongArray();
	argout->length(2);
	(*argout)[0] = 0;
	(*argout)[1] = 0;
	DEBUG_STREAM << "Rontec::get_spectrum_limits(): entering... !" << endl;

	//	Add your own code to control device here
	long start, step, sum,end;
	start = end = 0;
		// use of automatic_mutex :
		// la classe locke le mutex passé en argument ( pointeur ) a la creation 
		// unlock du mutex a la destruction de la classe ( en fin de visibilité si statique 
		// c'est la fin de visibilite qui nous interesse le mutex est unlocked de facon sure
		// donc alloc statique
		automatic_mutex m(&serial_access);
		mca->get_spectrum_reading_properties(start, step, sum, end);

	(*argout)[0] = start;
	(*argout)[1] = end;

	return argout;
}


//+------------------------------------------------------------------
/**
 *	method: Rontec::get_remaining_acquisition_time
 *
 *	description:	method to execute "GetRemainingAcquisitionTime"
 *	returns acquisition time remaining as read on the RONTEC ( $MR
 *
 * @return	acquisition time remainnig 
 *
 */
//+------------------------------------------------------------------
Tango::DevDouble Rontec::get_remaining_acquisition_time()
{
	Tango::DevDouble	argout ;
	long t = 0;
	DEBUG_STREAM << "Rontec::get_remaining_acquisition_time(): entering... !" << endl;
	//	Add your own code to control device here
		// use of automatic_mutex :
		// la classe locke le mutex passé en argument ( pointeur ) a la creation 
		// unlock du mutex a la destruction de la classe ( en fin de visibilité si statique 
		// c'est la fin de visibilite qui nous interesse le mutex est unlocked de facon sure
		// donc alloc statique
		automatic_mutex m(&serial_access);

		t = mca->get_remaining_acquisition_real_time();
	argout = static_cast<Tango::DevDouble>(t) / static_cast<Tango::DevDouble>(1000.0);
	return argout;
}

//+------------------------------------------------------------------
/**
 *	method: Rontec::get_part_of_spectrum
 *
 *	description:	method to execute "GetPartOfSpectrum"
 *	returns the data starting at argin[0] (exception if argin[0] < starting channel cofigured
 *	for argin[1] channel truncated if exceeds the end_channel configured
 *
 * @param argin [0]starting channel, [1] size of channel
 * @return	the data 
 *
 */
//+------------------------------------------------------------------
Tango::DevVarLongArray *Rontec::get_part_of_spectrum(const Tango::DevVarLongArray *argin)
{
	//	POGO has generated a method core with argout allocation.
	//	If you would like to use a static reference without copying,
	//	See "TANGO Device Server Programmer's Manual"
	//		(chapter : Writing a TANGO DS / Exchanging data)
	//------------------------------------------------------------
	DEBUG_STREAM << "Rontec::get_part_of_spectrum(): entering... !" << endl;
	//	Add your own code to control device here
	// control argin
	long len = argin->length();
	if(len < 2 )
	{
		ERROR_STREAM	<< "DATA_OUT_OF_RANGE Rontec::get_part_of_spectrum() must provide [0] : start channel, [1] : size " << endl;
		Tango::Except::throw_exception (
				(const char *)"DATA_OUT_OF_RANGE",
				(const char *)" must provide [0] : start channel, [1] : size ",
				(const char *)"Rontec::get_part_of_spectrum");
	}
	unsigned long * dat;

	try
	{
		dat = 0;
		dat = new unsigned long[((*argin)[1])];

		if (dat == 0)
		{
			ERROR_STREAM	<< "Rontec::get_part_of_spectrum() long buff allocation failed " << endl;
			Tango::Except::throw_exception (
					(const char *)"OUT_OF_MEMORY",
					(const char *)" long buff allocation failed ",
					(const char *)"Rontec::get_part_of_spectrum()");
		}
		::memset( (void *)dat, 0,  (*argin)[1] * sizeof(long) );
	}
	catch(...)
	{
		FATAL_STREAM	<< "OUT_OF_MEMORY Rontec::get_part_of_spectrum() : failed to create long	" << endl;
		Tango::Except::throw_exception (
				(const char *)"OUT_OF_MEMORY",
				(const char *)" failed to create long",
				(const char *)"Rontec::get_part_of_spectrum()");
	}

		// use of automatic_mutex :
		// la classe locke le mutex passé en argument ( pointeur ) a la creation 
		// unlock du mutex a la destruction de la classe ( en fin de visibilité si statique 
		// c'est la fin de visibilite qui nous interesse le mutex est unlocked de facon sure
		// donc alloc statique
		// dans un bloc de code marqué pour la visibilité
		{
			automatic_mutex m(&serial_access);
			mca->get_spectrum_data_2( (*argin)[0], (*argin)[1], dat );
		}
	try
	{
		Tango::DevVarLongArray	*argout  = new Tango::DevVarLongArray();
		argout->length( ((*argin)[1]) );
		for( int i = 0; i < ((*argin)[1]); i++)
		{
			(*argout)[i] = dat[i];
		}
		delete[] dat;
		return argout;
	}
	catch(...)
	{
		FATAL_STREAM	<< "OUT_OF_MEMORY Rontec::get_part_of_spectrum() : error on DevVarLongArray  " << endl;
		Tango::Except::throw_exception (
				(const char *)"OUT_OF_MEMORY",
				(const char *)" error on DevVarLongArray ",
				(const char *)"Rontec::get_part_of_spectrum()");

	}


	}

//+------------------------------------------------------------------
/**
 *	method: Rontec::get_roiparameters
 *
 *	description:	method to execute "GetROIParameters"
 *	returns the ROI output channel number parameters
 *	returns
 *	[0] = TTL output number
 *	[1] = low channel number
 *	[2] = high channel number
 *	according to the hardware parameters : max channel energy, offset an gain calibration
 *	not allowed if acquisition is running
 *	Exception if ROI number not in the ConnectedROIMask property
 *
 * @param argin TTL output number
 * @return	TTL output # low channel high channel
 *
 */
//+------------------------------------------------------------------
Tango::DevVarLongArray *Rontec::get_roiparameters(Tango::DevLong argin)
{
	//	POGO has generated a method core with argout allocation.
	//	If you would like to use a static reference without copying,
	//	See "TANGO Device Server Programmer's Manual"
	//		(chapter : Writing a TANGO DS / Exchanging data)
	//------------------------------------------------------------
	Tango::DevVarLongArray	*argout  = new Tango::DevVarLongArray();
	argout->length(3);
	(*argout)[0] = 0;
	DEBUG_STREAM << "Rontec::get_roiparameters(): entering... !" << endl;

	if(!is_ROI_configured(argin) )
	{
		ERROR_STREAM << "DATA_OUT_OF_RANGE Rontec::get_roiparameters(): ttl output number not configured in property" << endl;
		Tango::Except::throw_exception (
			(const char *)"DATA_OUT_OF_RANGE",
			(const char *)" ttl output number not configured in property ",
			(const char *)"Rontec::get_roiparameters");

	}

	//	Add your own code to control device here
	long ttl = argin;
	long atom, low_chan, high_chan;
	std::string name;
		// use of automatic_mutex :
		// la classe locke le mutex passé en argument ( pointeur ) a la creation 
		// unlock du mutex a la destruction de la classe ( en fin de visibilité si statique 
		// c'est la fin de visibilite qui nous interesse le mutex est unlocked de facon sure
		// donc alloc statique
		automatic_mutex m(&serial_access);
		mca->roi_get_parameters(ttl, atom, name, low_chan, high_chan);

	INFO_STREAM << "GetROIParameters : ttl output number :" << ttl << "  atomic number :" << atom << "	name :" << name << "	low channel :" << low_chan << "  high chan :" << high_chan << endl;
	(*argout)[0] = ttl;
	(*argout)[1] = low_chan;
	(*argout)[2] = high_chan;

	return argout;

}
//+------------------------------------------------------------------
/**
 *	method: Rontec::set_roiparameters
 *
 *	description:	method to execute "SetROIParameters"
 *	configures the TTL output number for pulse output photons processed with
 *	low_channel < energy < high_channel
 *	the RONTEC waits for energy so we retreive energy in DServer from channel and MaxFluoEnergy
 *	channels are retreived according amplifier and energy calibration.
 *	not alowed if acquisition is running
 *	Exception if ROI number not in the ConnectedROIMask property
 *
 * @param argin [0] : TTL output number, [1] low channel, [2] high channel
 *
 */
//+------------------------------------------------------------------
void Rontec::set_roiparameters(const Tango::DevVarLongArray *argin)
{
	DEBUG_STREAM << "Rontec::set_roiparameters(): entering... !" << endl;

	//	Add your own code to control device here
	if(!is_ROI_configured((*argin)[0]) )
	{
		ERROR_STREAM << "DATA_OUT_OF_RANGE Rontec::set_roiparameters(): ttl output number not configured in property" << endl;
		Tango::Except::throw_exception (
			(const char *)"DATA_OUT_OF_RANGE",
			(const char *)" ttl output number not configured in property ",
			(const char *)"Rontec::set_roiparameters");

	}
	// enough arguments?
	long len = argin->length();
	if(len < 3 )
	{
		ERROR_STREAM	<< "DATA_OUT_OF_RANGE Rontec::set_roiparameters() must provide [0] : ttl outmut number, [1] : start channel, [2] : end channel	" << endl;
		Tango::Except::throw_exception (
				(const char *)"DATA_OUT_OF_RANGE",
				(const char *)" must provide [0] : ttl outmut number, [1] : start channel, [2] : end channel",
				(const char *)"Rontec::set_roiparameters");
	}
	long ttl = (*argin)[0];
	long atom = 1;
	std::string name = "NO";
	long start = (*argin)[1];
	long end = (*argin)[2];
		// use of automatic_mutex :
		// la classe locke le mutex passé en argument ( pointeur ) a la creation 
		// unlock du mutex a la destruction de la classe ( en fin de visibilité si statique 
		// c'est la fin de visibilite qui nous interesse le mutex est unlocked de facon sure
		// donc alloc statique
		automatic_mutex m(&serial_access);
		mca->roi_set_parameters(ttl, atom, name, start, end);
}


//+------------------------------------------------------------------
/**
 *	method: Rontec::dev_state
 *
 *	description:	method to execute "State"
 *	This command gets the device state (stored in its <i>device_state</i> data member) and returns it to the caller.
 *
 * @return	State Code
 *
 */
//+------------------------------------------------------------------
Tango::DevState Rontec::dev_state()
{
	Tango::DevState argout = DeviceImpl::dev_state();
	DEBUG_STREAM << "Rontec::dev_state(): entering... !" << endl;

	//	Add your own code to control device here
	if(!_serial_line_initialised || !init_rontec_done || !init_thread_done)
	{
		argout = Tango::FAULT;
		return argout;
	}

	std::string resp;
		// use of automatic_mutex :
		// la classe locke le mutex passé en argument ( pointeur ) a la creation 
		// unlock du mutex a la destruction de la classe ( en fin de visibilité si statique 
		// c'est la fin de visibilite qui nous interesse le mutex est unlocked de facon sure
		// donc alloc statique
		automatic_mutex m(&serial_access);
		resp = mca->get_pause_status();

	if(resp == std::string("RUNNING"))
		argout = Tango::RUNNING;
	else 
		argout = Tango::OFF;
	return argout;
}

//+------------------------------------------------------------------
/**
 *	method: Rontec::dev_status
 *
 *	description:	method to execute "Status"
 *	This command gets the device status (stored in its <i>device_status</i> data member) and returns it to the caller.
 *
 * @return	Status descrition
 *
 */
//+------------------------------------------------------------------
Tango::ConstDevString Rontec::dev_status()
{
	DEBUG_STREAM << "Rontec::dev_status(): entering... !" << endl;
	//	Add your own code to control device here
	if(!_serial_line_initialised )
	{
		status_str = " serial line not initialised check property ";
		return status_str.c_str();
	}
	if(!init_rontec_done )
	{
		status_str = " initialisation of Rontec failed or software fatal error ";
		return status_str.c_str();
	}
	if(!init_thread_done)
	{
		status_str = " spectrum reader thread failed softwre fatal error";
		return status_str.c_str();
	}
	std::string resp;
		// use of automatic_mutex :
		// la classe locke le mutex passé en argument ( pointeur ) a la creation 
		// unlock du mutex a la destruction de la classe ( en fin de visibilité si statique 
		// c'est la fin de visibilite qui nous interesse le mutex est unlocked de facon sure
		// donc alloc statique
		automatic_mutex m(&serial_access);
		resp = mca->get_pause_status();
	status_str = " acquisition " + resp;
	return status_str.c_str();
}

//+------------------------------------------------------------------
/**
 *	method: Rontec::init_serial_line
 *
 *	description:	method to execute "InitSerialLine"
 *
 *
 */
//+------------------------------------------------------------------
void Rontec::init_serial_line(void)
{
	DEBUG_STREAM << "Rontec::init_serial_line(): entering... !" << endl;
	if( _serialProxy_helper )
	{
		delete _serialProxy_helper;
		_serialProxy_helper = 0;
	}
	_serialProxy_helper = 	new Tango::DeviceProxyHelper(serialLineUrl,this);
	_serialProxy_helper->command_in("DevSerSetBaudrate", static_cast<Tango::DevULong>(baud));
	_serialProxy_helper->command_in("DevSerSetNewline", static_cast<Tango::DevShort>(13));
	_serialProxy_helper->command_in("DevSerSetTimeout", static_cast<Tango::DevShort>(1000));
	set_state(Tango::OFF);

}

//+------------------------------------------------------------------
/**
 *	method: Rontec::reset
 *
 *	description:	method to execute "Reset"
 *
 * @return	string returend by the rontec
 *
 */
//+------------------------------------------------------------------
Tango::DevString Rontec::reset()
{
	//	POGO has generated a method core with argout allocation.
	//	If you would like to use a static reference without copying,
	//	See "TANGO Device Server Programmer's Manual"
	//		(chapter : Writing a TANGO DS / Exchanging data)
	//------------------------------------------------------------
	Tango::DevString	argout;

	DEBUG_STREAM << "Rontec::reset(): entering... !" << endl;
	//	Add your own code to control device here
	Tango::ConstDevString resp;
		// use of automatic_mutex :
		// la classe locke le mutex passé en argument ( pointeur ) a la creation 
		// unlock du mutex a la destruction de la classe ( en fin de visibilité si statique 
		// c'est la fin de visibilite qui nous interesse le mutex est unlocked de facon sure
		// donc alloc statique
		automatic_mutex m(&serial_access);
		resp = mca->reset();
	argout = CORBA::string_dup(resp);
	return argout;
}

//+------------------------------------------------------------------
/**
 *	method: Rontec::clear
 *
 *	description:	method to execute "Clear"
 *	clears the acquisition memory
 *
 *
 */
//+------------------------------------------------------------------
void Rontec::clear()
{
	DEBUG_STREAM << "Rontec::clear(): entering... !" << endl;
	//	Add your own code to control device here

		// use of automatic_mutex :
		// la classe locke le mutex passé en argument ( pointeur ) a la creation 
		// unlock du mutex a la destruction de la classe ( en fin de visibilité si statique
		// c'est la fin de visibilite qui nous interesse le mutex est unlocked de facon sure
		// donc alloc statique
		automatic_mutex m(&serial_access);
		mca->clear();

}




//+------------------------------------------------------------------
/**
 *	method: Rontec::get_speed_and_resolution_configuration
 *
 *	description:	method to execute "GetSpeedAndResolutionConfiguration"
 *	returns the processor configured :
 *	0 : max cps 1 : ... cps 2 : ..... cps 3 : min cps
 *
 * @return	processor number actually selected
 *
 */
//+------------------------------------------------------------------
Tango::DevLong Rontec::get_speed_and_resolution_configuration()
{
	Tango::DevLong	argout ;
	DEBUG_STREAM << "Rontec::get_speed_and_resolution_configuration(): entering... !" << endl;

	//	Add your own code to control device here
		// use of automatic_mutex :
		// la classe locke le mutex passé en argument ( pointeur ) a la creation 
		// unlock du mutex a la destruction de la classe ( en fin de visibilité si statique 
		// c'est la fin de visibilite qui nous interesse le mutex est unlocked de facon sure
		// donc alloc statique
		automatic_mutex m(&serial_access);
		argout =	mca->get_filter_setting();
	return argout;
}

//+------------------------------------------------------------------
/**
 *	method: Rontec::set_speed_and_resolution_configuration
 *
 *	description:	method to execute "SetSpeedAndResolutionConfiguration"
 *	selects the processor
 *	0 : max cps ...... 3 : min cps
 *	depends on real hardware
 *	exception if error
 *
 * @param argin the processor selected 0..3
 *
 */
//+------------------------------------------------------------------
void Rontec::set_speed_and_resolution_configuration(Tango::DevLong argin)
{
	DEBUG_STREAM << "Rontec::set_speed_and_resolution_configuration(): entering... !" << endl;
	//	Add your own code to control device here
		// use of automatic_mutex :
		// la classe locke le mutex passé en argument ( pointeur ) a la creation 
		// unlock du mutex a la destruction de la classe ( en fin de visibilité si statique 
		// c'est la fin de visibilite qui nous interesse le mutex est unlocked de facon sure
		// donc alloc statique
		automatic_mutex m(&serial_access);
		mca->set_filter_setting(argin);
}

//+------------------------------------------------------------------
/**
 *	method: Rontec::get_detector_temperature
 *
 *	description:	method to execute "GetDetectorTemperature"
 *
 * @return	
 *
 */
//+------------------------------------------------------------------
Tango::DevFloat Rontec::get_detector_temperature()
{
	Tango::DevFloat argout ;
	DEBUG_STREAM << "Rontec::get_detector_temperature(): entering... !" << endl;

	//	Add your own code to control device here
		// use of automatic_mutex :
		// la classe locke le mutex passé en argument ( pointeur ) a la creation 
		// unlock du mutex a la destruction de la classe ( en fin de visibilité si statique 
		// c'est la fin de visibilite qui nous interesse le mutex est unlocked de facon sure
		// donc alloc statique
		automatic_mutex m(&serial_access);
		argout = mca->get_detector_temperature();
	return argout;
}

//+------------------------------------------------------------------
/**
 *	method: Rontec::get_roi_count
 *
 *	description:	method to execute "GetRoiCount"
 *	total counts in te parameterised ROI.
 *	Exception if ROI number not in the ConnectedROIMask property
 *	response is delayed when acquisition is running
 *
 * @param argin TTL output number
 * @return	counts accumulated from starting
 *
 */
//+------------------------------------------------------------------
Tango::DevLong Rontec::get_roi_count(Tango::DevLong argin)
{
	Tango::DevLong	argout ;
	DEBUG_STREAM << "Rontec::get_roi_count(): entering... !" << endl;

	//	Add your own code to control device here
	if(!is_ROI_configured(argin) )
	{
		ERROR_STREAM << "DATA_OUT_OF_RANGE Rontec::get_roi_count(): ttl output number not configured in property" << endl;
		Tango::Except::throw_exception (
			(const char *)"DATA_OUT_OF_RANGE",
			(const char *)" ttl output number not configured in property ",
			(const char *)"Rontec::get_roi_count");

	}
		// use of automatic_mutex :
		// la classe locke le mutex passé en argument ( pointeur ) a la creation 
		// unlock du mutex a la destruction de la classe ( en fin de visibilité si statique 
		// c'est la fin de visibilite qui nous interesse le mutex est unlocked de facon sure
		// donc alloc statique
		automatic_mutex m(&serial_access);
		argout = mca->roi_get_count(argin);
	return argout;
}

//+------------------------------------------------------------------
/**
 *	method: Rontec::get_input_count_rate
 *
 *	description:	method to execute "GetInputCountRate"
 *
 * @return	the input count rate
 *
 */
//+------------------------------------------------------------------
Tango::DevLong Rontec::get_input_count_rate()
{
	Tango::DevLong	argout ;
	DEBUG_STREAM << "Rontec::get_input_count_rate(): entering... !" << endl;

	//	Add your own code to control device here
		// use of automatic_mutex :
		// la classe locke le mutex passé en argument ( pointeur ) a la creation 
		// unlock du mutex a la destruction de la classe ( en fin de visibilité si statique 
		// c'est la fin de visibilite qui nous interesse le mutex est unlocked de facon sure
		// donc alloc statique
		automatic_mutex m(&serial_access);
		argout = mca->get_input_count_rate();
	return argout;
}

//+------------------------------------------------------------------
/**
 *	method: Rontec::get_output_count_rate
 *
 *	description:	method to execute "GetOutputCountRate"
 *
 * @return	the output count rate
 *
 */
//+------------------------------------------------------------------
Tango::DevLong Rontec::get_output_count_rate()
{
	Tango::DevLong	argout ;
	DEBUG_STREAM << "Rontec::get_output_count_rate(): entering... !" << endl;

	//	Add your own code to control device here
		// use of automatic_mutex :
		// la classe locke le mutex passé en argument ( pointeur ) a la creation 
		// unlock du mutex a la destruction de la classe ( en fin de visibilité si statique 
		// c'est la fin de visibilite qui nous interesse le mutex est unlocked de facon sure
		// donc alloc statique
		automatic_mutex m(&serial_access);
		argout = mca->get_output_count_rate();
	return argout;
}

//+------------------------------------------------------------------
/**
 *	method: Rontec::get_dead_time
 *
 *	description:	method to execute "GetDeadTime"
 *
 * @return	the dead time ( % of non-processed counts )
 *
 */
//+------------------------------------------------------------------
Tango::DevFloat Rontec::get_dead_time()
{
	Tango::DevFloat argout ;
	DEBUG_STREAM << "Rontec::get_dead_time(): entering... !" << endl;

	//	Add your own code to control device here
		// use of automatic_mutex :
		// la classe locke le mutex passé en argument ( pointeur ) a la creation 
		// unlock du mutex a la destruction de la classe ( en fin de visibilité si statique 
		// c'est la fin de visibilite qui nous interesse le mutex est unlocked de facon sure
		// donc alloc statique
		automatic_mutex m(&serial_access);
		argout = mca->get_dead_time();
 return argout;
}

//+------------------------------------------------------------------
/**
 *	method: Rontec::get_cycle_time
 *
 *	description:	method to execute "GetCycleTime"
 *	returns the cycle time for input and outputs
 *
 * @return	the cycle time in ms
 *
 */
//+------------------------------------------------------------------
Tango::DevLong Rontec::get_cycle_time()
{
	Tango::DevLong	argout ;
	DEBUG_STREAM << "Rontec::get_cycle_time(): entering... !" << endl;

	//	Add your own code to control device here
		// use of automatic_mutex :
		// la classe locke le mutex passé en argument ( pointeur ) a la creation 
		// unlock du mutex a la destruction de la classe ( en fin de visibilité si statique 
		// c'est la fin de visibilite qui nous interesse le mutex est unlocked de facon sure
		// donc alloc statique
		automatic_mutex m(&serial_access);
		argout = mca->get_cycle_time();
	return argout;
}




//+------------------------------------------------------------------
/**
 *	method: Rontec::get_energy_range
 *
 *	description:	method to execute "GetEnergyRange"
 *	returns the energy range read from the RONTEC, in eV
 *
 * @return	the energy range in eV
 *
 */
//+------------------------------------------------------------------
Tango::DevLong Rontec::get_energy_range()
{
	Tango::DevLong	argout ;
	DEBUG_STREAM << "Rontec::get_energy_range(): entering... !" << endl;

	//	Add your own code to control device here
	
		// use of automatic_mutex :
		// la classe locke le mutex passé en argument ( pointeur ) a la creation 
		// unlock du mutex a la destruction de la classe ( en fin de visibilité si statique 
		// c'est la fin de visibilite qui nous interesse le mutex est unlocked de facon sure
		// donc alloc statique
		automatic_mutex m(&serial_access);
		argout = mca->retreive_energy_range();
	return argout;
}


//+------------------------------------------------------------------
/**
 *	method: Rontec::get_offset_gain
 *
 *	description:	method to execute "GetOffsetGain"
 *	returns the raw values of offset an gain as read in the RONTEC
 *
 * @return	[0] the offset, [1] the gain
 *
 */
//+------------------------------------------------------------------
Tango::DevVarLongArray *Rontec::get_offset_gain()
{
	//	POGO has generated a method core with argout allocation.
	//	If you would like to use a static reference without copying,
	//	See "TANGO Device Server Programmer's Manual"
	//		(chapter : Writing a TANGO DS / Exchanging data)
	//------------------------------------------------------------
	Tango::DevVarLongArray	*argout  = new Tango::DevVarLongArray();
	DEBUG_STREAM << "Rontec::get_offset_gain(): entering... !" << endl;

	//	Add your own code to control device here
	Tango::DevLong of,g;
		// use of automatic_mutex :
		// la classe locke le mutex passé en argument ( pointeur ) a la creation 
		// unlock du mutex a la destruction de la classe ( en fin de visibilité si statique 
		// c'est la fin de visibilite qui nous interesse le mutex est unlocked de facon sure
		// donc alloc statique
		automatic_mutex m(&serial_access);
		mca->retreive_offset_gain(of,g);
	argout->length(2);
	(*argout)[0] = of;
	(*argout)[1] = g;

	return argout;
}


//+------------------------------------------------------------------
/**
 *	method: Rontec::get_pause_status
 *
 *	description:	method to execute "GetPauseStatus"
 *	returns PAUSE or RUNNING according to acquisition stopped or running
 *
 * @return	PAUSE/RUNNING
 *
 */
//+------------------------------------------------------------------
Tango::DevString Rontec::get_pause_status()
{
	//	POGO has generated a method core with argout allocation.
	//	If you would like to use a static reference without copying,
	//	See "TANGO Device Server Programmer's Manual"
	//		(chapter : Writing a TANGO DS / Exchanging data)
	//------------------------------------------------------------
	Tango::DevString	argout;
	DEBUG_STREAM << "Rontec::get_pause_status(): entering... !" << endl;
	std::string tmp;
	//	Add your own code to control device here
		// use of automatic_mutex :
		// la classe locke le mutex passé en argument ( pointeur ) a la creation 
		// unlock du mutex a la destruction de la classe ( en fin de visibilité si statique 
		// c'est la fin de visibilite qui nous interesse le mutex est unlocked de facon sure
		// donc alloc statique
		automatic_mutex m(&serial_access);
		tmp = mca->get_pause_status();
	argout = CORBA::string_dup(tmp.c_str());
	return argout;
}

//+------------------------------------------------------------------
/**
 *	method: Rontec::is_ROI_configured
 *
 *	description:	internal method
 *	controls if ttl output number in argin is configured in connectedROIMask property
 *
 * @return	true if configured
 *
 */
//+------------------------------------------------------------------

bool Rontec::is_ROI_configured(long ttl_number)
{
	DEBUG_STREAM << "Rontec::is_ROI_configured(): entering... !" << endl;
	std::stringstream s;
	s << ttl_number << ends;
	std::string configured;
	configured = connectedROIMask;
	if( configured.find(s.str().c_str()) != std::string::npos )
	{
		return true;
	}
	return false;


}


//+------------------------------------------------------------------
/**
 *	method: Rontec::set_read_size
 *
 *	description:	method to execute "SetReadSize"
 *	for the readin thread ,
 *	the number of channels to read in 1 shoot on the RONTEC MCA.
 *	low number increases the speed of reading.
 *
 * @param argin size to read in 1 shoot
 *
 */
//+------------------------------------------------------------------
void Rontec::set_read_size(Tango::DevLong argin)
{
	DEBUG_STREAM << "Rontec::set_read_size(): entering... !" << endl;
	DEBUG_STREAM << "Rontec::set_read_size(): not implemented " << endl;

	//	Add your own code to control device here


}

//+------------------------------------------------------------------
/**
 *	method: Rontec::get_acquisition_time
 *
 *	description:	method to execute "GetAcquisitionTime"
 *	returns the time spent in the current acquisition
 *
 * @return	time in sec of the current acquisition
 *
 */
//+------------------------------------------------------------------
Tango::DevDouble Rontec::get_acquisition_time()
{
	Tango::DevDouble	argout ;
	DEBUG_STREAM << "Rontec::get_acquisition_time(): entering... !" << endl;
	long val = 0;
	//	Add your own code to control device here
		// use of automatic_mutex :
		// la classe locke le mutex passé en argument ( pointeur ) a la creation 
		// unlock du mutex a la destruction de la classe ( en fin de visibilité si statique 
		// c'est la fin de visibilite qui nous interesse le mutex est unlocked de facon sure
		// donc alloc statique
		automatic_mutex m(&serial_access);
		val = mca->get_elapsed_acquisition_real_time();
	argout = static_cast<Tango::DevDouble>(val) / 1000.0;
	return argout;
}

//+------------------------------------------------------------------
/**
 *	method: Rontec::set_energy_range
 *
 *	description:	method to execute "SetEnergyRange"
 *
 * @param argin energy 10000 or 20000 or 40000 or 80000
 *
 */
//+------------------------------------------------------------------
void Rontec::set_energy_range(Tango::DevLong argin)
{
	DEBUG_STREAM << "Rontec::set_energy_range(): entering... !" << endl;

	//	Add your own code to control device here
		// use of automatic_mutex :
		// la classe locke le mutex passé en argument ( pointeur ) a la creation
		// unlock du mutex a la destruction de la classe ( en fin de visibilité si statique
		// c'est la fin de visibilite qui nous interesse le mutex est unlocked de facon sure
		// donc alloc statique
		automatic_mutex m(&serial_access);
		mca->set_energy_range(argin);
}

//+------------------------------------------------------------------
/**
 *	method: Rontec::send_rontec_message
 *
 *	description:	method to execute "SendRontecMessage"
 *
 * @param argin the command and arguments to be sent
 * @return	the rontec answer as string
 *
 */
//+------------------------------------------------------------------
Tango::DevString Rontec::send_rontec_message(Tango::DevString argin)
{
	//	POGO has generated a method core with argout allocation.
	//	If you would like to use a static reference without copying,
	//	See "TANGO Device Server Programmer's Manual"
	//		(chapter : Writing a TANGO DS / Exchanging data)
	//------------------------------------------------------------
	Tango::DevString	argout;
	DEBUG_STREAM << "Rontec::send_rontec_message(): entering... !" << endl;
	//	Add your own code to control device here
	std::string command(argin);
	std::string response ;
		// use of automatic_mutex :
		// la classe locke le mutex passé en argument ( pointeur ) a la creation 
		// unlock du mutex a la destruction de la classe ( en fin de visibilité si statique
		// c'est la fin de visibilite qui nous interesse le mutex est unlocked de facon sure
		// donc alloc statique
		automatic_mutex m(&serial_access);
		response = mca->SendRontecMessage(command);
	argout = CORBA::string_dup(response.c_str());
	return argout;
}

} //	namespace
